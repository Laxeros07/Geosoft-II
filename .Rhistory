4+5
a04+5
4=4+5
a=4+5
a
b
b=1+2
b
a=5/(5+34)
?sin
b=2*sin(90)
c=sqrt(16)+sqrt(25)
d=(a+b)/c
?seq
?rep
rep.int(1, 5)
load("students.rdata")
load("students.rdata")
load("C:/Users/Felix/Desktop/Studium/Uni Fächer/2. Semester/Geostatistik/R-Dateien/Datensätze/students.rdata")
data(iris) # lade den Datensatz
iris[40:60,] # Zeige Zeilen 40 bis 60
?mean
mean(Sepal.Length)
mean(iris.Sepal.Length)
mean(iris[,1])
iris
i=iris[40:60,]
mean(i[,1])
sd(i[,1])
?sd
median(i[,1])
?quantile
quantile(i[,1],0.1)
quantile(i[,1],0.5)
quantile(i[,1],0.1)
quantile(i[,1],0.9)
?sort
sort(iris$Sepal.Length[40:60])[11]
ls()
str(students)
table(students$EyeColor)
table(students$Gender)
table(students$Age)
table(students$Length)
table(students$Iam)
table(students$Country)
table(students$FieldOfStudies)
table(students$Semester)
h=hist(students$Length, plot=FALSE)
h
5+27
hist(students$Length)
?sum
med <- median(students$Length, na.rm = TRUE)
students$ali <- ((students$Semester / 2) / students$Age) * 100
quartiles.students$ali
quantile(students$ali, fracs, na.rm = TRUE)
quantile(students$ali, na.rm = TRUE)
?str
?which
str(students$ali)
str(students$ali.which(10))
str(students$ali.which(>=10))
str(students$ali.which(x>=10))
str(which(students$ali>=10))
students$ali
str(which(students$ali>=10))/str(which(students$ali>=0))
which(students$ali>=10)/which(students$ali>=0)
9/133
students.m <- students[students$Gender == "m", ]
plot(x = students.m$Age, y = students.m$Semester)
mean(students.m$Semester, na.rm = TRUE)
median(students.m$Semester, na.rm = TRUE)
students.m.clean <- students.m[students.m$Semester < 10, ]
median(students.m.clean$Semester, na.rm = TRUE)
mean(students.m.clean$Semester, na.rm = TRUE)
mean(students.m$Semester, trim = 0.1, na.rm = TRUE)
mean(students.m$Semester, trim = 0.3, na.rm = TRUE)
mean(students.m$Semester, trim = 0.5, na.rm = TRUE)
median(students.m$Semester, na.rm = TRUE)
?mean
?quartil
?quartil
?quartiles
?quartile
?quatile
?quantile
quantile(students$Length, fracs,na.rm = TRUE)
quantile(students$Length,na.rm = TRUE)
fracs = c(0.25)
fracs = c(0.75)
quantile(students$Length, fracs, na.rm = TRUE)
fracz = c(0.75)
quantile(students$Length, fracz, na.rm = TRUE) -quantile(students$Length, fracs, na.rm = TRUE)
fracs = c(0.25)
fracz = c(0.75)
quantile(students$Length, fracz, na.rm = TRUE) - quantile(students$Length, fracs, na.rm = TRUE)
quantile(students$Length, fracz, na.rm = TRUE)
quantile(students$Length, fracs, na.rm = TRUE)
?na.omit
h=hist(students$Length, plot=FALSE)
h
hist(students$Length)
h= 170 < hist(students$Length, plot=FALSE) < 180
?which
sum(which(170<hist(students$Length, plot=FALSE)<180))
sum(which(hist(students$Length, plot=FALSE)<180))
sum(hist(students$Length, plot=FALSE)<180)
students$Length
sum(which(students$Length<180))
sum(which(170<students$Length<180))
sum(which(students$Length<180&&<170))
sum(which(students$Length<180&&>170))
(which(students$Length<180))
(which(students$Length<180 && >170))
(which(170<students$Length<180))
sum(students$Length<180)
sum(170<students$Length<180)
sum(students$Length<180&&students$Length>170)
sum(students$Length<180&&>170)
students$Length
hist(students$Length, plot=FALSE)
sum(students$Length=180)
sum(students$Length=170)
sum(students$Length==170)
sum(students$Length==180)
> hist(students$Length, plot=FALSE)
hist(students$Length, plot=FALSE)
sum(students$Length==170)
sum(students$Length==180)
hist(students$Length)
50-3-9
sum(students$Length==150)
sum(students$Length==170)
5+27-3
sum(students$Length<=180)
quantile(students$ali, na.rm = TRUE)
quantile(stdents$ali, c(0.25))
quantile(students$ali, c(0.25))
quantile(students$ali, c(0.25),na.rm = TRUE)
which(students$ali>=10)/which(students$ali>=0)
which(students$ali>=10)
which(students$ali>=0)
9/133
plot(x = students.m$Age, y = students.m$Semester)
mean(students.m$Semester, na.rm = TRUE)
median(students.m$Semester, na.rm = TRUE)
students.m.clean <- students.m[students.m$Semester < 10, ]
mean(students.m.clean$Semester, na.rm = TRUE)
median(students.m.clean$Semester, na.rm = TRUE)
load("ex01_AABU.rdata")
load("ex01_AABU.Rdata")
load("ex01_AABU.Rdata")
load("ex01_AABU.Rdata")
summary(AABU.obs)
## librarys installieren
library(terra)
library(sf)
library(caret)
library(raster)
library(CAST)
# zum testen wd so setzen
setwd("C:/Users/Felix/Desktop/Studium/Uni Fächer/4. Semester/Geosoft 1/Geosoft-II")
rasterdaten <- rast(paste(
getwd(),
"/public/uploads/rasterdaten.tif",
sep = ""
))
trainingsdaten <- read_sf(paste(
getwd(),
"/public/uploads/trainingsdaten.geojson",
sep = ""
))
modell <- readRDS(paste(
getwd(),
"/public/uploads/modell.RDS",
sep = ""
))
maske <- ext(rasterdaten)
## Ausgabe
klassifizierung_mit_Modell <- function(rasterdaten, modell) {
# klassifizieren
### little detour due to terra/raster change
prediction <- predict(as(rasterdaten, "Raster"), modell)
projection(prediction)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
prediction_terra <- as(prediction, "SpatRaster")
# erste Visualisierung der Klassifikation:
# plot(prediction_terra)
# und nochmal in schöner plotten mit sinnvollen Farben
cols <- c(
"lightgreen", "blue", "green", "darkred", "forestgreen",
"darkgreen", "beige", "darkblue", " firebrick1", "red", "yellow"
)
# plot(prediction_terra,col=cols)
# export raster
# writeRaster(prediction_terra,"prediction.grd",overwrite=TRUE)
# return(plot(prediction_terra)) # ,col=cols))
terra::writeRaster(prediction_terra, paste(
getwd(),
"/public/uploads/prediction_modell.tif",
sep = ""
), overwrite = TRUE)
# AOA Berechnungen
AOA_klassifikation <- aoa(rasterdaten,model)
crs(AOA_klassifikation$AOA)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
#plot(AOA_klassifikation$DI)
#plot(AOA_klassifikation$AOA)
terra::writeRaster(AOA_klassifikation$AOA, paste(
getwd(),
"/public/uploads/AOA_klassifikation_modell.tif",
sep = ""
), overwrite = TRUE)
}
## Ausgabe
klassifizierung_ohne_Modell <- function(maske) {
## Variablen definieren
predictors <- c(
"B02", "B03", "B04", "B08", "B05", "B06", "B07", "B11",
"B12", "B8A"
)
rasterdaten <- crop(rasterdaten, maske)
# Trainingsdaten umprojizieren, falls die Daten verschiedene CRS haben
trainingsdaten <- st_transform(trainingsdaten, crs(rasterdaten))
# Daten mergen
extr <<- extract(rasterdaten, trainingsdaten)
# head(extr)
# head(trainingsdaten)
trainingsdaten$PolyID <- 1:nrow(trainingsdaten)
extr <<- merge(extr, trainingsdaten, by.x = "ID", by.y = "PolyID")
# head(extr)
# Modell trainieren
# nicht alle Daten verwenden um Rechenzeit zu sparen
extr_subset <- extr[createDataPartition(extr$ID, p = 0.2)$Resample1, ]
# eventuell Daten limitieren.
# Verhälnis der Daten aus jedem Trainingsgebiet soll aber gleich bleiben
# hier:10% aus jedem Trainingsgebiet (see ?createDataPartition)
trainIDs <- createDataPartition(extr$ID, p = 0.1, list = FALSE)
trainDat <- extr[trainIDs, ]
# Sicherstellen das kein NA in Prädiktoren enthalten ist:
trainDat <- trainDat[complete.cases(trainDat[, predictors]), ]
#### Modelltraining
model <- train(trainDat[, predictors],
trainDat$Label,
method = "rf",
importance = TRUE,
ntree = 50
) # 50 is quite small (default=500). But it runs faster.
#saveRDS(model, "C:/Users/Felix/Desktop/Studium/Uni Fächer/4. Semester/Geosoft 1/Geosoft-II/public/uploads/modell.RDS")
# model
# plot(model) # see tuning results
# plot(varImp(model)) # variablenwichtigkeit
# Farbpalette
cols <- c(
"beige", "sandybrown",
"blue3", "red", "magenta", "red", "darkgoldenrod", "lightgreen", "blue", "green", "deeppink4", "grey", "chartreuse", "deeppink3",
"deepskyblue4", "forestgreen", "brown", "darkgreen"
)
# klassifizieren
### little detour due to terra/raster change
prediction <- predict(as(rasterdaten, "Raster"), model)#, colors(cols))
projection(prediction)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
prediction_terra <- as(prediction, "SpatRaster")
coltab(prediction_terra) <- cols
#?predict
# erste Visualisierung der Klassifikation:
# plot(prediction_terra)
# plot(prediction_terra,col=cols)
# export raster
# writeRaster(prediction_terra,"prediction.grd",overwrite=TRUE)
# return(plot(prediction_terra)) # ,col=cols))
#tiff(paste(
#  getwd(),
# "/public/uploads/prediction.geotiff",
#  sep = ""
# ))
# terra::plot(prediction_terra,col=cols, legend=FALSE, axes = FALSE, buffer=FALSE)
# dev.off()
# ?writeRaster
#?terra::plot
#prediction_terra
#png(paste(
#   getwd(),
#   "/public/uploads/prediction.geotiff",
#   sep = ""
# ), bg="transparent")
# plot(NULL ,xaxt='n',yaxt='n',bty='n',ylab='',xlab='', xlim=0:1, ylim=0:1)
# legend("topleft", legend =prediction_terra$names, pch=16, pt.cex=3, cex=1.5, bty='n',
#                      col = cols)
#                      mtext("Species", at=0.2, cex=2)
# dev.off()
# ?terra::plot
# writeRaster(prediction_terra, "D:/Dokumente/Studium/5 FS/Geosoftware II/geosoft-II/public/uploads/prediction.tif", overwrite = TRUE)
# filename <- paste(normalizePath("D:/Dokumente/Studium"), "\\prediction.tif", sep = "")
# stop(getwd())
terra::writeRaster(prediction_terra, paste(
getwd(),
"/public/uploads/prediction.tif",
sep = ""
), overwrite = TRUE)
#plot(prediction_terra)
#writeRaster(prediction_terra, filename="public/uploads/prediction2.tif", format="GTiff", overwrite=TRUE)
# library(tmap)
# crs(prediction_terra) <- "+proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
# map <- tm_shape(prediction_terra,
#                raster.downsample = FALSE) +
#  tm_raster(palette = cols,title = "LUC")+
#  tm_scale_bar(bg.color="white")+
#  tm_grid(n.x=4,n.y=4,projection="+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")+
#  tm_layout(legend.position = c("left","bottom"),
#            legend.bg.color = "white",
#            legend.bg.alpha = 0.8)#+
# tmap_save(map, paste(
#  getwd(),
#  "/public/uploads/map.png",
#  sep = ""
# ))
# AOA Berechnungen
AOA_klassifikation <- aoa(rasterdaten,model)
crs(AOA_klassifikation$AOA)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
#plot(AOA_klassifikation$DI)
#plot(AOA_klassifikation$AOA)
terra::writeRaster(AOA_klassifikation$AOA, paste(
getwd(),
"/public/uploads/AOA_klassifikation.tif",
sep = ""
), overwrite = TRUE)
}
# zum Testen der Funktionen
# klassifizierung_mit_Modell(rasterdaten, modell)
klassifizierung_ohne_Modell(maske)
maske
rasterdaten <- rast(paste(
getwd(),
"/public/uploads/rasterdaten.tif",
sep = ""
))
trainingsdaten <- read_sf(paste(
getwd(),
"/public/uploads/trainingsdaten.geojson",
sep = ""
))
modell <- readRDS(paste(
getwd(),
"/public/uploads/modell.RDS",
sep = ""
))
maske <- c(7.54738996178022, 7.65064656833175, 51.9272943715445, 52.0101517816852)
## Ausgabe
klassifizierung_mit_Modell <- function(rasterdaten, modell) {
# klassifizieren
### little detour due to terra/raster change
prediction <- predict(as(rasterdaten, "Raster"), modell)
projection(prediction)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
prediction_terra <- as(prediction, "SpatRaster")
# erste Visualisierung der Klassifikation:
# plot(prediction_terra)
# und nochmal in schöner plotten mit sinnvollen Farben
cols <- c(
"lightgreen", "blue", "green", "darkred", "forestgreen",
"darkgreen", "beige", "darkblue", " firebrick1", "red", "yellow"
)
# plot(prediction_terra,col=cols)
# export raster
# writeRaster(prediction_terra,"prediction.grd",overwrite=TRUE)
# return(plot(prediction_terra)) # ,col=cols))
terra::writeRaster(prediction_terra, paste(
getwd(),
"/public/uploads/prediction_modell.tif",
sep = ""
), overwrite = TRUE)
# AOA Berechnungen
AOA_klassifikation <- aoa(rasterdaten,model)
crs(AOA_klassifikation$AOA)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
#plot(AOA_klassifikation$DI)
#plot(AOA_klassifikation$AOA)
terra::writeRaster(AOA_klassifikation$AOA, paste(
getwd(),
"/public/uploads/AOA_klassifikation_modell.tif",
sep = ""
), overwrite = TRUE)
}
## Ausgabe
klassifizierung_ohne_Modell <- function(maske) {
## Variablen definieren
predictors <- c(
"B02", "B03", "B04", "B08", "B05", "B06", "B07", "B11",
"B12", "B8A"
)
rasterdaten <- crop(rasterdaten, maske)
# Trainingsdaten umprojizieren, falls die Daten verschiedene CRS haben
trainingsdaten <- st_transform(trainingsdaten, crs(rasterdaten))
# Daten mergen
extr <<- extract(rasterdaten, trainingsdaten)
# head(extr)
# head(trainingsdaten)
trainingsdaten$PolyID <- 1:nrow(trainingsdaten)
extr <<- merge(extr, trainingsdaten, by.x = "ID", by.y = "PolyID")
# head(extr)
# Modell trainieren
# nicht alle Daten verwenden um Rechenzeit zu sparen
extr_subset <- extr[createDataPartition(extr$ID, p = 0.2)$Resample1, ]
# eventuell Daten limitieren.
# Verhälnis der Daten aus jedem Trainingsgebiet soll aber gleich bleiben
# hier:10% aus jedem Trainingsgebiet (see ?createDataPartition)
trainIDs <- createDataPartition(extr$ID, p = 0.1, list = FALSE)
trainDat <- extr[trainIDs, ]
# Sicherstellen das kein NA in Prädiktoren enthalten ist:
trainDat <- trainDat[complete.cases(trainDat[, predictors]), ]
#### Modelltraining
model <- train(trainDat[, predictors],
trainDat$Label,
method = "rf",
importance = TRUE,
ntree = 50
) # 50 is quite small (default=500). But it runs faster.
#saveRDS(model, "C:/Users/Felix/Desktop/Studium/Uni Fächer/4. Semester/Geosoft 1/Geosoft-II/public/uploads/modell.RDS")
# model
# plot(model) # see tuning results
# plot(varImp(model)) # variablenwichtigkeit
# Farbpalette
cols <- c(
"beige", "sandybrown",
"blue3", "red", "magenta", "red", "darkgoldenrod", "lightgreen", "blue", "green", "deeppink4", "grey", "chartreuse", "deeppink3",
"deepskyblue4", "forestgreen", "brown", "darkgreen"
)
# klassifizieren
### little detour due to terra/raster change
prediction <- predict(as(rasterdaten, "Raster"), model)#, colors(cols))
projection(prediction)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
prediction_terra <- as(prediction, "SpatRaster")
coltab(prediction_terra) <- cols
#?predict
# erste Visualisierung der Klassifikation:
# plot(prediction_terra)
# plot(prediction_terra,col=cols)
# export raster
# writeRaster(prediction_terra,"prediction.grd",overwrite=TRUE)
# return(plot(prediction_terra)) # ,col=cols))
#tiff(paste(
#  getwd(),
# "/public/uploads/prediction.geotiff",
#  sep = ""
# ))
# terra::plot(prediction_terra,col=cols, legend=FALSE, axes = FALSE, buffer=FALSE)
# dev.off()
# ?writeRaster
#?terra::plot
#prediction_terra
#png(paste(
#   getwd(),
#   "/public/uploads/prediction.geotiff",
#   sep = ""
# ), bg="transparent")
# plot(NULL ,xaxt='n',yaxt='n',bty='n',ylab='',xlab='', xlim=0:1, ylim=0:1)
# legend("topleft", legend =prediction_terra$names, pch=16, pt.cex=3, cex=1.5, bty='n',
#                      col = cols)
#                      mtext("Species", at=0.2, cex=2)
# dev.off()
# ?terra::plot
# writeRaster(prediction_terra, "D:/Dokumente/Studium/5 FS/Geosoftware II/geosoft-II/public/uploads/prediction.tif", overwrite = TRUE)
# filename <- paste(normalizePath("D:/Dokumente/Studium"), "\\prediction.tif", sep = "")
# stop(getwd())
terra::writeRaster(prediction_terra, paste(
getwd(),
"/public/uploads/prediction.tif",
sep = ""
), overwrite = TRUE)
#plot(prediction_terra)
#writeRaster(prediction_terra, filename="public/uploads/prediction2.tif", format="GTiff", overwrite=TRUE)
# library(tmap)
# crs(prediction_terra) <- "+proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
# map <- tm_shape(prediction_terra,
#                raster.downsample = FALSE) +
#  tm_raster(palette = cols,title = "LUC")+
#  tm_scale_bar(bg.color="white")+
#  tm_grid(n.x=4,n.y=4,projection="+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")+
#  tm_layout(legend.position = c("left","bottom"),
#            legend.bg.color = "white",
#            legend.bg.alpha = 0.8)#+
# tmap_save(map, paste(
#  getwd(),
#  "/public/uploads/map.png",
#  sep = ""
# ))
# AOA Berechnungen
AOA_klassifikation <- aoa(rasterdaten,model)
crs(AOA_klassifikation$AOA)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
#plot(AOA_klassifikation$DI)
#plot(AOA_klassifikation$AOA)
terra::writeRaster(AOA_klassifikation$AOA, paste(
getwd(),
"/public/uploads/AOA_klassifikation.tif",
sep = ""
), overwrite = TRUE)
}
# zum Testen der Funktionen
# klassifizierung_mit_Modell(rasterdaten, modell)
klassifizierung_ohne_Modell(maske)
ext(rasterdaten)
