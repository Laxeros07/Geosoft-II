legend_plot <- ggplot()+
geom_spatraster(data=prediction_terra)+
scale_fill_manual(values=farben[2:12], na.value=NA)
legend <- get_legend(legend_plot)
ggsave(paste(
getwd(),
"/public/uploads/legend.png",
sep = ""
), plot= legend, width = 2, height = 3)
# Abfrage, ob bereits eine AOA gerechnet wurde
AOA_Differenz_nötig <- FALSE
if(file.exists(paste(
getwd(),
"/public/uploads/AOA_klassifikation.tif",
sep = ""
))){
AOA_Differenz_nötig <- TRUE
AOA_klassifikation_alt<- rast(paste(
getwd(),
"/public/uploads/AOA_klassifikation.tif",
sep = ""
))
}
# AOA Berechnungen
AOA_klassifikation <- aoa(rasterdaten,modell)
crs(AOA_klassifikation$AOA)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
crs(AOA_klassifikation$DI)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
#plot(AOA_klassifikation$DI)
#plot(AOA_klassifikation$AOA)
terra::writeRaster(AOA_klassifikation$AOA, paste(
getwd(),
"/public/uploads/AOA_klassifikation_modell.tif",
sep = ""
), overwrite = TRUE)
# DI Berechnungen
maxDI <- selectHighest(AOA_klassifikation$DI, 3000)
crs(maxDI)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
#terra::writeRaster(maxDI, paste(
#  getwd(),
#  "/public/uploads/maxDI.tif",
#  sep = ""
#), overwrite = TRUE)
# DI als GeoJSON exportieren
maxDIVector <- as.polygons(maxDI)
crs(maxDIVector)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
terra::writeVector(maxDIVector, paste(
getwd(),
"/public/uploads/maxDI.geojson",
sep = ""
), filetype="geojson", overwrite = TRUE)
# AOA Differenz berechnen
if(AOA_Differenz_nötig == TRUE){
AOA_klassifikation_alt <- crop(AOA_klassifikation_alt, ext(AOA_klassifikation$AOA))
AOA_klassifikation$AOA <- crop(AOA_klassifikation$AOA, ext(AOA_klassifikation_alt))
differenz <- AOA_klassifikation$AOA - AOA_klassifikation_alt
terra::writeRaster(differenz, paste(
getwd(),
"/public/uploads/AOADifferenz.tif",
sep = ""
), overwrite = TRUE)
} # 1=Verbesserung der AOA; 0=keine Veränderung; -1=Verschlechterung der AOA
}
## Variablen definieren
predictors <- c(
"B02", "B03", "B04", "B05", "B06", "B07", "B08", "B8A", "B09", "B10", "B11", "B12")
# Rasterdaten zuschneiden
rasterdaten <- crop(rasterdaten, maske_raster)
# Trainingsdaten zuschneiden
class(maske_raster) <- "numeric"
#class(maske_raster)
#plot(ext(maske_training))
sf_use_s2(FALSE)
trainingsdaten2 <- st_make_valid(trainingsdaten)
trainingsdaten <- st_crop(trainingsdaten2, ext(maske_training))
# Trainingsdaten umprojizieren, falls die Daten verschiedene CRS haben
trainingsdaten <- st_transform(trainingsdaten, crs(rasterdaten))
# Daten mergen
extr <<- extract(rasterdaten, trainingsdaten)
# head(extr)
# head(trainingsdaten)
trainingsdaten$PolyID <- 1:nrow(trainingsdaten)
extr <<- merge(extr, trainingsdaten, by.x = "ID", by.y = "PolyID")
# Modell trainieren
# nicht alle Daten verwenden um Rechenzeit zu sparen
extr_subset <- extr[createDataPartition(extr$ID, p = datenanteil)$Resample1, ]
# eventuell Daten limitieren.
# Verhälnis der Daten aus jedem Trainingsgebiet soll aber gleich bleiben
trainIDs <- createDataPartition(extr$ID, p = datenanteil, list = FALSE)
algorithmus <- "rf"
trainDat <- extr[trainIDs, ]
# Sicherstellen das kein NA in Prädiktoren enthalten ist:
trainDat <- trainDat[complete.cases(trainDat[, predictors]), ]
if(algorithmus == "rf") {
# Hyperparameter für Modelltraining abfragen
if(is.na(baumAnzahl)){
baumAnzahl <- 50
}
if(is.na(baumTiefe)){
baumTiefe <- 50
}
#### Modelltraining
model <- train(trainDat[, predictors],
trainDat$Label,
method = "rf",
importance = TRUE,
ntree = baumAnzahl,  # Anzahl der Bäume
maxnodes = baumTiefe   # Tiefe der Bäume
) # 50 is quite small (default=500). But it runs faster.
} else {
#print(algorithmus)
model <- train(trainDat[, predictors],
trainDat$Label,
method="rpart",
trControl = trainControl(method = "cv")   # Classification Tree Algorithmus
) # nicht so gut wie rf Algorithmus
}
# Farbpalette
#cols <- c(
#  "beige", "sandybrown",
#  "blue3", "red", "magenta", "red", "darkgoldenrod", "lightgreen", "blue", "green", "deeppink4", "grey", "chartreuse", "deeppink3",
#  "deepskyblue4", "forestgreen", "brown", "darkgreen"
#)
# klassifizieren
### little detour due to terra/raster change
prediction <- predict(as(rasterdaten, "Raster"), model)#, colors(cols))
projection(prediction)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
prediction_terra <- as(prediction, "SpatRaster")
farben <- brewer.pal(n = 12, name = "Paired")
coltab(prediction_terra) <- farben#[0:12]
plot(prediction_terra)
# Prediction Legende exportieren
legend_plot <- ggplot()+
geom_spatraster(data=prediction_terra)+
scale_fill_manual(values=farben[2:12], na.value=NA)
plot(legend_plot)
# zum testen wd so setzen
setwd("C:/Users/Felix/Desktop/Studium/Uni Fächer/4. Semester/Geosoft 1/Geosoft-II")
rasterdaten <- rast(paste(
getwd(),
"/public/beispieldaten/rasterdaten.tif",
sep = ""
))
trainingsdaten <- read_sf(paste(
getwd(),
"/public/uploads/trainingsdaten3.geojson",
sep = ""
))
modell <- readRDS(paste(
getwd(),
"/public/uploads/modell.RDS",
sep = ""
))
maske_raster <- c(7.55738996178022, 7.64064656833175, 51.9372943715445, 52.0001517816852)
maske_training <- c(xmin =7.55738996178022, ymin =51.9372943715445, xmax =7.64064656833175, ymax =52.0001517816852)
baumAnzahl <- NA
baumTiefe <- NA
algorithmus <- "rf"
datenanteil <- 0.1
## Ausgabe
klassifizierung_mit_Modell <- function(rasterdaten, modell, maske_raster) {
# Rasterdaten zuschneiden
rasterdaten <- crop(rasterdaten, maske_raster)
# klassifizieren
### little detour due to terra/raster change
prediction <- predict(as(rasterdaten, "Raster"), modell)
projection(prediction)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
prediction_terra <- as(prediction, "SpatRaster")
farben <- brewer.pal(n = 12, name = "Paired")
coltab(prediction_terra) <- farben#[0:10]
# erste Visualisierung der Klassifikation:
# plot(prediction_terra)
# und nochmal in schöner plotten mit sinnvollen Farben
cols <- c(
"lightgreen", "blue", "green", "darkred", "forestgreen",
"darkgreen", "beige", "darkblue", " firebrick1", "red", "yellow"
)
# plot(prediction_terra,col=cols)
# export raster
# writeRaster(prediction_terra,"prediction.grd",overwrite=TRUE)
# return(plot(prediction_terra)) # ,col=cols))
terra::writeRaster(prediction_terra, paste(
getwd(),
"/public/uploads/prediction_modell.tif",
sep = ""
), overwrite = TRUE)
# Prediction Legende exportieren
legend_plot <- ggplot()+
geom_spatraster(data=prediction_terra)+
scale_fill_manual(values=farben[2:12], na.value=NA)
legend <- get_legend(legend_plot)
ggsave(paste(
getwd(),
"/public/uploads/legend.png",
sep = ""
), plot= legend, width = 2, height = 3)
# Abfrage, ob bereits eine AOA gerechnet wurde
AOA_Differenz_nötig <- FALSE
if(file.exists(paste(
getwd(),
"/public/uploads/AOA_klassifikation.tif",
sep = ""
))){
AOA_Differenz_nötig <- TRUE
AOA_klassifikation_alt<- rast(paste(
getwd(),
"/public/uploads/AOA_klassifikation.tif",
sep = ""
))
}
# AOA Berechnungen
AOA_klassifikation <- aoa(rasterdaten,modell)
crs(AOA_klassifikation$AOA)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
crs(AOA_klassifikation$DI)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
#plot(AOA_klassifikation$DI)
#plot(AOA_klassifikation$AOA)
terra::writeRaster(AOA_klassifikation$AOA, paste(
getwd(),
"/public/uploads/AOA_klassifikation_modell.tif",
sep = ""
), overwrite = TRUE)
# DI Berechnungen
maxDI <- selectHighest(AOA_klassifikation$DI, 3000)
crs(maxDI)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
#terra::writeRaster(maxDI, paste(
#  getwd(),
#  "/public/uploads/maxDI.tif",
#  sep = ""
#), overwrite = TRUE)
# DI als GeoJSON exportieren
maxDIVector <- as.polygons(maxDI)
crs(maxDIVector)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
terra::writeVector(maxDIVector, paste(
getwd(),
"/public/uploads/maxDI.geojson",
sep = ""
), filetype="geojson", overwrite = TRUE)
# AOA Differenz berechnen
if(AOA_Differenz_nötig == TRUE){
AOA_klassifikation_alt <- crop(AOA_klassifikation_alt, ext(AOA_klassifikation$AOA))
AOA_klassifikation$AOA <- crop(AOA_klassifikation$AOA, ext(AOA_klassifikation_alt))
differenz <- AOA_klassifikation$AOA - AOA_klassifikation_alt
terra::writeRaster(differenz, paste(
getwd(),
"/public/uploads/AOADifferenz.tif",
sep = ""
), overwrite = TRUE)
} # 1=Verbesserung der AOA; 0=keine Veränderung; -1=Verschlechterung der AOA
}
## Variablen definieren
predictors <- c(
"B02", "B03", "B04", "B05", "B06", "B07", "B08", "B8A", "B09", "B10", "B11", "B12")
# Rasterdaten zuschneiden
rasterdaten <- crop(rasterdaten, maske_raster)
# Trainingsdaten zuschneiden
class(maske_raster) <- "numeric"
#class(maske_raster)
#plot(ext(maske_training))
sf_use_s2(FALSE)
trainingsdaten2 <- st_make_valid(trainingsdaten)
trainingsdaten <- st_crop(trainingsdaten2, ext(maske_training))
# Trainingsdaten umprojizieren, falls die Daten verschiedene CRS haben
trainingsdaten <- st_transform(trainingsdaten, crs(rasterdaten))
# Daten mergen
extr <<- extract(rasterdaten, trainingsdaten)
# head(extr)
# head(trainingsdaten)
trainingsdaten$PolyID <- 1:nrow(trainingsdaten)
extr <<- merge(extr, trainingsdaten, by.x = "ID", by.y = "PolyID")
# Modell trainieren
# nicht alle Daten verwenden um Rechenzeit zu sparen
extr_subset <- extr[createDataPartition(extr$ID, p = datenanteil)$Resample1, ]
# eventuell Daten limitieren.
# Verhälnis der Daten aus jedem Trainingsgebiet soll aber gleich bleiben
trainIDs <- createDataPartition(extr$ID, p = datenanteil, list = FALSE)
trainDat <- extr[trainIDs, ]
# Sicherstellen das kein NA in Prädiktoren enthalten ist:
trainDat <- trainDat[complete.cases(trainDat[, predictors]), ]
if(algorithmus == "rf") {
# Hyperparameter für Modelltraining abfragen
if(is.na(baumAnzahl)){
baumAnzahl <- 50
}
if(is.na(baumTiefe)){
baumTiefe <- 50
}
#### Modelltraining
model <- train(trainDat[, predictors],
trainDat$Label,
method = "rf",
importance = TRUE,
ntree = baumAnzahl,  # Anzahl der Bäume
maxnodes = baumTiefe   # Tiefe der Bäume
) # 50 is quite small (default=500). But it runs faster.
} else {
#print(algorithmus)
model <- train(trainDat[, predictors],
trainDat$Label,
method="rpart",
trControl = trainControl(method = "cv")   # Classification Tree Algorithmus
) # nicht so gut wie rf Algorithmus
}
# Farbpalette
#cols <- c(
#  "beige", "sandybrown",
#  "blue3", "red", "magenta", "red", "darkgoldenrod", "lightgreen", "blue", "green", "deeppink4", "grey", "chartreuse", "deeppink3",
#  "deepskyblue4", "forestgreen", "brown", "darkgreen"
#)
# klassifizieren
### little detour due to terra/raster change
prediction <- predict(as(rasterdaten, "Raster"), model)#, colors(cols))
projection(prediction)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
prediction_terra <- as(prediction, "SpatRaster")
farben <- brewer.pal(n = 12, name = "Paired")
coltab(prediction_terra) <- farben#[0:12]
plot(prediction_terra)
# Prediction Legende exportieren
legend_plot <- ggplot()+
geom_spatraster(data=prediction_terra)+
scale_fill_manual(values=farben[2:12], na.value=NA)
plot(legend_plot)
# zum testen wd so setzen
setwd("C:/Users/Felix/Desktop/Studium/Uni Fächer/4. Semester/Geosoft 1/Geosoft-II")
rasterdaten <- rast(paste(
getwd(),
"/public/beispieldaten/rasterdaten.tif",
sep = ""
))
trainingsdaten <- read_sf(paste(
getwd(),
"/public/uploads/trainingsgebiete.geojson",
sep = ""
))
modell <- readRDS(paste(
getwd(),
"/public/uploads/modell.RDS",
sep = ""
))
maske_raster <- c(7.55738996178022, 7.64064656833175, 51.9372943715445, 52.0001517816852)
maske_training <- c(xmin =7.55738996178022, ymin =51.9372943715445, xmax =7.64064656833175, ymax =52.0001517816852)
baumAnzahl <- NA
baumTiefe <- NA
algorithmus <- "rf"
datenanteil <- 0.1
## Ausgabe
klassifizierung_mit_Modell <- function(rasterdaten, modell, maske_raster) {
# Rasterdaten zuschneiden
rasterdaten <- crop(rasterdaten, maske_raster)
# klassifizieren
### little detour due to terra/raster change
prediction <- predict(as(rasterdaten, "Raster"), modell)
projection(prediction)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
prediction_terra <- as(prediction, "SpatRaster")
farben <- brewer.pal(n = 12, name = "Paired")
coltab(prediction_terra) <- farben#[0:10]
# erste Visualisierung der Klassifikation:
# plot(prediction_terra)
# und nochmal in schöner plotten mit sinnvollen Farben
cols <- c(
"lightgreen", "blue", "green", "darkred", "forestgreen",
"darkgreen", "beige", "darkblue", " firebrick1", "red", "yellow"
)
# plot(prediction_terra,col=cols)
# export raster
# writeRaster(prediction_terra,"prediction.grd",overwrite=TRUE)
# return(plot(prediction_terra)) # ,col=cols))
terra::writeRaster(prediction_terra, paste(
getwd(),
"/public/uploads/prediction_modell.tif",
sep = ""
), overwrite = TRUE)
# Prediction Legende exportieren
legend_plot <- ggplot()+
geom_spatraster(data=prediction_terra)+
scale_fill_manual(values=farben[2:12], na.value=NA)
legend <- get_legend(legend_plot)
ggsave(paste(
getwd(),
"/public/uploads/legend.png",
sep = ""
), plot= legend, width = 2, height = 3)
# Abfrage, ob bereits eine AOA gerechnet wurde
AOA_Differenz_nötig <- FALSE
if(file.exists(paste(
getwd(),
"/public/uploads/AOA_klassifikation.tif",
sep = ""
))){
AOA_Differenz_nötig <- TRUE
AOA_klassifikation_alt<- rast(paste(
getwd(),
"/public/uploads/AOA_klassifikation.tif",
sep = ""
))
}
# AOA Berechnungen
AOA_klassifikation <- aoa(rasterdaten,modell)
crs(AOA_klassifikation$AOA)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
crs(AOA_klassifikation$DI)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
#plot(AOA_klassifikation$DI)
#plot(AOA_klassifikation$AOA)
terra::writeRaster(AOA_klassifikation$AOA, paste(
getwd(),
"/public/uploads/AOA_klassifikation_modell.tif",
sep = ""
), overwrite = TRUE)
# DI Berechnungen
maxDI <- selectHighest(AOA_klassifikation$DI, 3000)
crs(maxDI)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
#terra::writeRaster(maxDI, paste(
#  getwd(),
#  "/public/uploads/maxDI.tif",
#  sep = ""
#), overwrite = TRUE)
# DI als GeoJSON exportieren
maxDIVector <- as.polygons(maxDI)
crs(maxDIVector)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
terra::writeVector(maxDIVector, paste(
getwd(),
"/public/uploads/maxDI.geojson",
sep = ""
), filetype="geojson", overwrite = TRUE)
# AOA Differenz berechnen
if(AOA_Differenz_nötig == TRUE){
AOA_klassifikation_alt <- crop(AOA_klassifikation_alt, ext(AOA_klassifikation$AOA))
AOA_klassifikation$AOA <- crop(AOA_klassifikation$AOA, ext(AOA_klassifikation_alt))
differenz <- AOA_klassifikation$AOA - AOA_klassifikation_alt
terra::writeRaster(differenz, paste(
getwd(),
"/public/uploads/AOADifferenz.tif",
sep = ""
), overwrite = TRUE)
} # 1=Verbesserung der AOA; 0=keine Veränderung; -1=Verschlechterung der AOA
}
## Variablen definieren
predictors <- c(
"B02", "B03", "B04", "B05", "B06", "B07", "B08", "B8A", "B09", "B10", "B11", "B12")
# Rasterdaten zuschneiden
rasterdaten <- crop(rasterdaten, maske_raster)
# Trainingsdaten zuschneiden
class(maske_raster) <- "numeric"
#class(maske_raster)
#plot(ext(maske_training))
sf_use_s2(FALSE)
trainingsdaten2 <- st_make_valid(trainingsdaten)
trainingsdaten <- st_crop(trainingsdaten2, ext(maske_training))
# Trainingsdaten umprojizieren, falls die Daten verschiedene CRS haben
trainingsdaten <- st_transform(trainingsdaten, crs(rasterdaten))
# Daten mergen
extr <<- extract(rasterdaten, trainingsdaten)
# head(extr)
# head(trainingsdaten)
trainingsdaten$PolyID <- 1:nrow(trainingsdaten)
extr <<- merge(extr, trainingsdaten, by.x = "ID", by.y = "PolyID")
# Modell trainieren
# nicht alle Daten verwenden um Rechenzeit zu sparen
extr_subset <- extr[createDataPartition(extr$ID, p = datenanteil)$Resample1, ]
# eventuell Daten limitieren.
# Verhälnis der Daten aus jedem Trainingsgebiet soll aber gleich bleiben
trainIDs <- createDataPartition(extr$ID, p = datenanteil, list = FALSE)
trainDat <- extr[trainIDs, ]
# Sicherstellen das kein NA in Prädiktoren enthalten ist:
trainDat <- trainDat[complete.cases(trainDat[, predictors]), ]
if(algorithmus == "rf") {
# Hyperparameter für Modelltraining abfragen
if(is.na(baumAnzahl)){
baumAnzahl <- 50
}
if(is.na(baumTiefe)){
baumTiefe <- 50
}
#### Modelltraining
model <- train(trainDat[, predictors],
trainDat$Label,
method = "rf",
importance = TRUE,
ntree = baumAnzahl,  # Anzahl der Bäume
maxnodes = baumTiefe   # Tiefe der Bäume
) # 50 is quite small (default=500). But it runs faster.
} else {
#print(algorithmus)
model <- train(trainDat[, predictors],
trainDat$Label,
method="rpart",
trControl = trainControl(method = "cv")   # Classification Tree Algorithmus
) # nicht so gut wie rf Algorithmus
}
# Farbpalette
#cols <- c(
#  "beige", "sandybrown",
#  "blue3", "red", "magenta", "red", "darkgoldenrod", "lightgreen", "blue", "green", "deeppink4", "grey", "chartreuse", "deeppink3",
#  "deepskyblue4", "forestgreen", "brown", "darkgreen"
#)
# klassifizieren
### little detour due to terra/raster change
prediction <- predict(as(rasterdaten, "Raster"), model)#, colors(cols))
projection(prediction)<- "+proj=longlat +datum=WGS84 +no_defs +type=crs"
prediction_terra <- as(prediction, "SpatRaster")
farben <- brewer.pal(n = 12, name = "Paired")
coltab(prediction_terra) <- farben#[0:12]
#terra::plot(prediction_terra, col=farben[1:12])
test <- as.polygons(prediction_terra)
test1 <- values(test)[,1]
test2 <- sort(trainingsdaten$Label)
test2 <- unique(test2)
test2
test1
plot(prediction_terra)
# Prediction Legende exportieren
legend_plot <- ggplot()+
geom_spatraster(data=prediction_terra)+
scale_fill_manual(values=farben[2:12], na.value=NA)
plot(legend_plot)
